# 요약 #
  * 내용 :  Go언어 관련 자주 묻는 질문
  * 원문 : [Go FAQ](http://golang.org/doc/go_faq.html)
  * 번역자 : jeyong@gmail.com




# Go언어 관련 자주 묻는 질문 #
## 유래 ##
### 이 프로젝트의 목적은? ###
10년이상 주요 시스템 개발 언어가 나오지 않았는데 그동안 컴퓨팅 환경은 엄청 바뀌었다. 아래와 같은 트렌드가 있다.
  * 컴퓨터는 엄청나게 빨라졌는데 소프트웨어 개발은 그렇지 않다.
  * 의존성 관리가 현재는 소프트웨어 개발의 중요한 요소인데 C에서 헤더 파일은 의존성 분석을 깔끔하게 하는 것을 어렵게 한다. 빠른 컴파일도 중요한 요소다.
  * Python과 JavaScript와 같은 동적 타입 언어(dynamically typed language)에 대한 요구
  * 가비지 콜렉션(garbage collection)과 병렬처리(parallel computation)과 같은 기본 개념이 시스템 개발 언어에서 잘 지원되지 않고 있다.
  * 멀티코어 컴퓨터의 출현으로 신경써야할 것이 더 많아졌다.

동시성(concurrent) 및 가비지 콜렉션을 지원하면서 빠른 컴파일을 지원하는 새로운 개발언어를 개발하는 것은 충분한 가치가 있다고 믿고 있다.
  * 단일 PC에서 짧은 시간내에 덩치가 큰 Go 프로그램을 컴파일 할 수 있다.
  * 의존성 검사를 쉽게하고 C언어 형식의 include 파일 및 라이브러리의 오버헤드를 회피하는 소프트웨어에 대한 모델을 제공한다.
  * Go의 타입 시스템(type system)은 계층(hierarchy)가 없어서 타입 사이의 관계를 정의하는데 시간을 소비하지 않는다. 따라서 전형적인 객체지향언어 보다 가볍게 느끼게 하는 static 타입 언어다.
  * Go는 완전한 가비지 콜렉션과 동시 실행 및 통신(cocurrent execution and communication)을 기본으로 지원한다.
  * 설계적으로 멀티코어 환경에서 시스템 소프트웨어 구성하는 접근법을 제시한다.

### 프로젝트 이름은 어떻게 지어졌나요? ###
"Ogle"는 Go 디버거에 적당한 이름이었다.
### 마스코트는 어떻게 만들어 졌나요? ###
마스코트와 로고는  Glenda를 디자인를 디자인 했던 Renée French가 디자인했고 Plan 9도 참여. gopher는 몇 해 전 WFMU 티셔츠 디자인 했던 것 중에 하나다.
### 6g란? ###
6g(그리고 8g와 5g)컴파일러는 Plan 9 C 컴파일러의 전통을 따른 이름이다. (http://plan9.bell-labs.com/sys/doc/compiler.html). 6은 amd64에서 따왔고 g는 Go를 뜻한다.
### 프로젝트 진행 역사 ###
Robert Griesemer, Rob Pike와 Ken Thompson 이렇게 3명이서 2007년 9월 21일 화이트보드에 새로운 개발언어에 대한 목표를 설계하기 시작했다. 몇 일내로 무엇을하고 어떻게 될것인가에 대한 생각을 계획으로 세웠다. 설계는 다른 일을 하면서 파트타임으로 계속 했다. 2008년 1월까지 Ken은 아이디어를 실현하는 컴파일러 작업을 시작했다. 결과물로 C코드를 만들어 냈다. 2008년 중반에 와서 풀타임 프로젝트가 되었고 상품성있는 컴파일러가 되기에 충분해졌다. 2008년 5월에 Ian Taylor은 드래프트 스펙(draft specification)을 이용해서 독립적으로 Go를 위한 GCC front end를 시작했다. 2008년 후반에 Russ Cox가 참여하면서 언어와 라이브러리들에 대해 프로토타입으로부터 현실화 시켰다.

### 새로운 언어를 왜 만들었나? ###
Go는 시스템 프로그래밍에서 현존하는 언어와 환경의 문제점을 해결하기 위해서 태어났다. 프로그래밍은 매우 어렵고 개발언어의 선택에도 문제가 있다. 효과적인 컴파일과 실행 혹은 프로그래밍을 쉽게 할 것인지를 선택해야했다. 이 3가지를 동시에 만족하는 개발언어를 없었다. C++이나 Java보다는 Python이나 JavaScript와 같은 동적 타입 언어로 이동하면서 안전성과 효율성보다는 쉽게 프로그래밍하는 것을 선택하는 개발자도 있다.

Go는 인터프리터되는 프로그래밍이 쉽다는 것과 정적 타입 언어의 효율성과 안전성 및 컴파일 언어를 하나로 묶으려고 시도했다. 이를 통해 네트워크와 멀티코어 컴퓨팅을 지원하여 현재의 환경에 맞추는 것을 목표로 하고 있다. 마지막으로 빨라야 한다. 단일 컴퓨터에서 큰 파일을 빌드하는데 걸리는 시간이 짧아야 한다. 이 목표를 맞추기 위해서는 많은 언어적 이슈에 접근할 필요가 있었다. expressive하지만 경량 타입 시스템이어야 하고 동시성(concurrency)과 가비지 콜렌션을 지원하며 의존성에 관한 스펙을 엄격히 해야한다. 이런 것들은 라이브러리나 도구로 해결하기 힘들다. 따라서 새로운 개발언어가 필요했다.

### Go의 조상이 되는 언어는? ###
Go는 주로 문법을 C 계열이며 Pascal/Modula/Oberon(선언, 패키지) 계열, Tony Hoare의 CSP, Newsqueak, Limbo(동시성)에서 영감을 받았다. 그렇지만 새로운 개발언어다. 모든 면에서 개발언어는 프로그래머가 하는 일과 어떻게 프로그래밍을 하는지를 고려해서 설계 되며 어떤 종류의 일을 하는 프로그래머인지 어떤게 더 효과적인지를 고려하는데 이것들은 개발을 더 재밌게 하기 위해서다.
### 설계에서 가이드 원칙은 무엇인가? ###
## 사용 ##
### 이 언어를 누가 사용하지? ###
실험단계다. 새로운 것을 경험하고 싶은 사용자가 한 번 해보도록하고 잘 사용하는지를 보고 싶다. 모든 프로그래머는 아니겠지만 많은 프로그래머가 사용하면서 만족했으면 좋겠다.
### 구글에서 내부적으로 Go를 사용하나? ###
사용하고 있다. 구글내부에서 여러 프로젝트가 진행중이다. http://golang.org 서버 내부도 Go를 사용한 것이다.
### Go 프로그램은 C/C++ 프로그램과 링크가능한가? ###
2가지 Go 컴파일러가 있는데 하나는 6g계열(일반적으로  gc라 부른다)고 다른 하나는 gccgo다. Gc는 다른 호출 규약(calling convention)을 사용하므로 이와 같은 규약을 따르는 C프로그램만 링크(link)할 수 있다. C 컴파일러는 있지만 C++ 컴파일러는 안된다. gccgo는 GCC 프론트-엔드(front-end)여서 GCC로 컴파일된 C나 C++ 프로그램을 링크할 수 있다.
cgo는 외부 함수 인터페이스(foreign function interface)를 위한 방법을 제공하여 Go코드에서 C라이브러리를 안전하게 부를 수 있도록 한다. SWIG는 이런 특성을 C++라이브러리로 넓혔다.
### Go는 구글의 프로토콜 버퍼를 지원하는가? ###
다른 오픈소스 프로젝트에서 필요한 컴파일러 플러그인과 라이브러리를 제공한다. http://code.google.com/p/goprotobuf/

### Go 홈페이지 내용을 다른 나라 언어로 번역해도 되는가? ###
물론이다. 하지만 구글 로고는 사용하지 말라.
## 설계 ##
### 유니코드 식별자로 뭘하지? ###
ASCII로 한정되었던 식별자를 다양하게 지원하게 된 것은 중요하다. Go의 원칙(식별자 문자는 반드시 유니코드(Unicode)로 정의된 문자나 숫자여야 한다)은 제한은 있지만 이해하고 구현하기 단순하다. 문자을 조합하는 것은 설계에서 배제된다.
따라서 프로그램을 수정없이 이후에 확장될 수 있는 단순한 원칙들을 가지고 있다. 모호한 식별자를 인정하는 어떤 원칙으로부터 발생하는 버그를 피한다.

관련해서 알아야할 사항중에 외부에서 접근가능한 식별자는 반드시 대문자로 시작해야 하므로 영어이외의 언어를 사용한 경우 외부에서 접근할 수 없게 된다. 현재 해결방법으로 X日本語와 같은 방법을 사용하지만 만족스럽지 않다. 다른 옵션이 없는지를 계속 고민 중이다. 그렇다고 대소문자에 따른 가시성(case-for-visibility)원칙은 변경하고 싶지는 않다. 이는 Go의 좋은 특징이기 때문이다.

### 왜 Go는 X 기능이 없는가? ###
모든 언어들이 독특한 특징을 가지며 다른 언어들이 가지는 특징이 없어진다. Go는 프로그래밍의 적절한 표현, 컴파일 속도, 개념의 직교성(orthogonality), 동시성 및 가비지 콜렉션과 같은 특징을 지원하도록 설계 되었다. 여러분이 좋아하는 특징이 없을지도 모른다. 그러게 하면 목적에 맞지 않거나 컴파일 속도, 설계의 명료함, 혹은 기본 시스템 모델을 너무 어렵게 만들기 때문이다.

Go가 특정 기능을 지원하지 않아서 여러분에게 불편을 줬다면 이해해 주길 바라며 Go가 가지고 있는 특성을 공부해 보길 바란다. 여러분이 생각하는 부족한 특정 기능이 재밌는 방식으로 녹아들어 있다는 것을 발견할지도 모른다.
### 왜 Go는 generic 타입이 없을까? ###
generic은 때가 되면 추가될 수 있다. 현재 급하게 느낄 필요는 없다. 일부 프로그래머가 급하다고 느끼는 것을 이해하고 있다.
generic은 편리하지만 타입 시스템과 런타임에 복잡성을 줘서 비용이 증가한다. 증가한 복잡성에 비례하는 가치를 주는 것을 아직 찾지 못했지만 여전히 고려하고 있다. Go에 내장된 map과 slice에 추가로 컨테이너(container)를 구성하는 빈 인터페이스(empty interface)를 사용하면 많은 경우 generic으로 할 수 있는 것들을 작성하는 것이 가능하다. 약간은 자연스럽지 않을 수는 있다.

이것은 open 이슈로 남겨둔다.
### 왜 Go는 예외처리가 없을까? ###
try-catch-finally와 같은 예외처리를 제어 구조체로 묶는 것은 결과적으로 복잡한 코드가 된다. 또한 프로그래머로 하여금 파일 열기에 실패한 경우와 같이 무수히 많은 일상적인 에러에 대해서 분류하도록 한다.

Go는 다른 방법을 사용한다. 일반 예외처리 대신에 진짜 예외적인 상황일 때 신호를 주고 복구할 수 있는 내장 함수를 제공한다. 복구 방법은 에러 발생 후에 분해된 함수의 상태 일부를 수행한다. 이것으로도 추가적인 제어 구조가 없이 잘 사용하면 에러로 인한 큰 재앙들을 처리할 수 있다. 그리고 결과적으로 깔끔한 에러처리 코드가 된다.
[Defer, Panic, Recover](http://blog.golang.org/2010/08/defer-panic-and-recover.html)기사 참조
### 왜 Go는 assertion을 없을까? ###
Go는 assertion이 없다. 확실히 있으면 편리하지만 우리 경험에 비춰봤을 때 프로그래머들은 적절히 에러를 처리하고 리포팅에 관한 고려를 하지 않기 위한 도구로 사용하는 것을 여겨진다. 적절한 에러 처리는 서버가 심각한 에러가 아닌 상황을 맞았을 때 다운되지 않고 계속 동작하는 것을 말한다.
적절한 에러 리포팅은 에러를 바로 그 부분을 보게되어 프로그래머가 시스템을 망친 부분을 찾기 위해서 엄청난 메시지들을 분석하지 않다도 되도록 하는 것이다. 익숙하지 않은 코드에서 프로그래머가 에러를 보게 될 때 에러가 명확하게 드러나는 것이 특히 중요하다.

테스트 프로그램에서 assert()의 사용에도 동일한 생각이다. 테스트가 실패한 후에 다른 테스트를 실행하게 하는데도 적절한 에러 처리가 필요하다. 따라서 실패난 것을 디버깅 하는 사람은 무엇이 잘 못되었는지 완벽하게 이해할 수 있게 한다. isPrime이 잘못된 결과를 내는 것을 테스트하는데도 유용하다. 테스트가 실패하도록 하는 프로그래머는 실패하는 코드에도 익숙하지 않다. 멋진 에러 메시지를 작성하는데 투자하는 시간은 나중에 테스트가 멈출 때 보답하게 된다.

테스팅에서 에러를 위해 작성한 많은 코드들이 중복적이고 쓸데없이 보인다면 테이블 주도 테스트(table-driven test)를 추천한다. Go는 자료구조를 아주 잘 지원한다.

우리는 이런 부분은 논쟁의 소지가 있고 생각한다. Go언어에 있는 많은 것들과 라이브러리는 최근에 것들과 차이가 있다. 단순히 우리는 다른 접근법을 시도하는 것이 충분히 가치가 있다고 생각한다.
### 왜 CSP에서 동시성(concurrency)의 개념을 가져왔을까? ###
동시성(concurrency)와 멀티쓰레드(multi-threaded) 프로그래밍은 어렵기로 유명하다. 문제점은 pthread와 같은 복잡한 설계에 일부 책임이 있고 또 뮤텍스(mutex), 조건 변수, 메모리 경계 등으로 인해 로우레벨의 상세한 것들을 강조하는데 일부 책임이 있다. 더 상위 수준의 인터페이스로 더욱 단순한 코드를 가능케한다.(여전히 뮤텍스와 밑에 사용하는 것들은 있다.)

상위레벨 언어에서 제공하는 가장 성공적인 모델 중에 하나인 CSP(Communicating Sequential Processes)로서 동시성(concurrency)을 제공한다. Occam과 Erlang은 CSP를 뿌리로 하는 언어이다. Go의 동시성은 channel이라는 개념을 이용하는 약간은 다른 뿌리에서 나왔다.
### 왜 goroutine이 쓰레드(thread)를 대신할까? ###
goroutine은 동시성을 쉽게 이용할 수 있는 방법이다. 이 개념은 실제로는 coroutine처럼 다중 독립적 실행되는 함수들을 쓰레드들의 집합으로 보는 것이다. 블록킹 시스템 콜을 호출하는 것과 같이 어떤 coroutine이 block될 때, 자동적으로 런타임은 동일한 운연체제의 쓰레드에 있는 coroutine을 다른 곳으로 이동시키고 runnable 쓰레드로 인해 블록킹되지 않는다.  프로그래머는 실제 이런 동작을 보지 못하지만 이것이 핵심이다. 결과적으로 goroutine을 호출하면 아주 간단하다. 오래 실행되는 시스템 호출에서 많은 시간을 돌리지 않는다면 스택에 메모리와 비슷한 수준의 비용이 들게 되는 셈이다.

스택을 작게 만들기 위해 go의 런타임은 분할 스택(segmented stack)을 사용한다. 새로 만든 goroutine은 수 kilobyte만 할당되는데 이걸로 대부분 충분하다. 만약 충분하지 않을 경우에는 런타임 시스템이 자동으로 확장 세그먼트를 할당한다. 오버헤드는 함수 호출당 3개의 간단한 명령정도이다. 이렇게 하면 실제로 동일 주소공간에 있는 수만개의 goroutine을 생성할 수 있다. 만약 goroutine이 그냥 쓰레드였다면 시스템 리소스는 훨씬 적은 수의 것을 처리하면 다 바닥날 것이다.

### 왜 map관련 연산은 어토믹(atomic)으로 정의하지 않았나? ###
오랫동안 논의한 후에 map 일반 사용에서 다중 쓰레드로부터 안전하게 접근하는 것이 필요 없다고 결정했다. 만약 안전하게 접근해야한다면 더 큰 구조와 동기화된 계산 부분이 추가되어야 한다. 결과적으로 모든 map 연산은 뮤텍스(mutex)를 가져야 하므로 전반적으로 프로그램이 느려지게 된다. 제어가 안되는 map 접근은 프로그램을 붕괴시키기 때문에 쉬운 결정이 아니였다.

원자적 map 업데이트를 막아두지 않았다. 신뢰할 수 없는 프로그램을 호스팅하는 경우와 같이 필요할 때 구현에서 map접근을 안전하게 구동시킬 수 있다.

## 타입(Type) ##
### Go는 객체지향 언어인가? ###
그렇기도 하고 아니기도 하다. Go는 타입과 메소드를 가지고 객체지향 스타일의 프로그래밍을 허용하지만 타입 상속(type hierarchy)가 없다. Go에서 인터페이스 개념은 약간 다른 접근 방법을 제공하는데 우리는 사용하기 쉽고 어떤 경우에는 더 일반적이라고 생각한다. 다른 타입에 임베디드된 타입에 subclass와 유사하지만 같지는 않는 방법도 제공하고 있다. 더우기 Go에서 메소드는 C++이나 Java보다 더 일반적이다. 왜냐하면 struct가 아니라 data의 종류에 대해서 정의할 수 있기 때문이다.

또한 Go에서 부족한 타입 상속으로 "objects"를 만들게 되면, C++이나 Java 같은 언어들보다 아주 가볍다는 느낌을 느끼게 한다.

### 어떻게 메소드의 동적 디스패치(dynamic dispatch)를 할 수 있을까? ###
동적으로 디스패치되는 메소르(dynamically dispatched method)를 가지는 유일한 방법은 interface통해서만 가능하다. struct의 메소드나 다른 타입은 항상 정적(statically)으로 처리된다.

### 왜 타입 상속(type inheritance)이 없는가? ###
잘 알려진 개발언어들에서 객체지향 프로그래밍은 자동으로 유도된 타입(type)과 관계(relationship)들 사이의 관계에 대해서 아주 많은 논의가 있었다. Go는 다른 방법으로 접근한다.

프로그래머에게 2개의 타입이 관계를 맺는 시간을 선언하도록하는 대신에 Go에서는 메소드의 부분집합을 지정하는 인터페이스를 자동으로 타입이 만족시킨다. 기록남기(bookkeeping)는 것을 줄이뿐만 아니라 실제적인 이점이 많다. 타입은 종전의 다중 상속의 복잡성 없이 즉시 많은 인터페이스를 만족시킬 수 있다. 인터페이스는 배우 경량화되어 있어서 인터페이스에서 하나의 메소드 혹은 아예 메소드를 가지지 않을 때에도 유용한 개념을 표현할 수 있다. 인터페이스는 새로운 개념이 나오거나 테스팅을 할 때도 원래의 타입을 수정하지 않고 인터페이스를 추가할 수 있다. 왜냐하면 타입과 인터페이스 사이에는 어떠한 명시적인 관계도 설정하지 않기 때문이다.

안전한 타입(type-safe)을 가지는 유닉스 파이프(pipe)와 유사한 것을 만들기 위해 이런 개념을 사용할 수 있다. 예를 들면 fmt.Fprintf가 어떻게 출력부로 포맷화해서 프린트가 가능한지를 보여준다. 혹은 bufio 패키지는 완전히 파일 I/O와 분리시키거나 crypto 패키지는 블록으로 묶어서 암호화한 것을 스트림으로 보내는 것을 볼 수 있다. 이런 모든 개념들의 줄기는 단일 method(Write)를 나타내는 단일 인터페이스(io.Writer)이다. 그리고 여기서는 단지 겉만 알아봤다.

익숙해 지려면 시간이 좀 걸리겠지만 타입 의존성에 대해서 암시적인 방법(implicit style)을 사용하는 것은 Go와 관련된 가장 중요한 요소 중에 하나이다.

### 왜 len은 메소드가 아니라 함수인가? ###
이 문제에 대해서 논쟁이 있었지만 함수로 남겨두기로 결정했다. 실용적으로 함수로 두는 것도 괜찮았다. 기본 타입의 인터페이스를 복잡하게 하고 싶지 않았다.

### 왜 Go는 메소드의 오버로딩(overloading)과 연산자(operator)를 지원하지 않는가? ###
타입 매칭(type matching)이 없다면 메소드 디스패치를 단순화 시킬 수 있다. 다른 언어를 접한 경험에 따라 동일한 이름이지만 시그네쳐가 다른 다양한 메소드를 가지는 경우 가끔은 유용할 수 있겠지만 실제로 보면 헷갈리고 오래 유지되지 않더라. 이름으로만 구분하고 타입을 일치시키도록 하는 것은 Go에서 단순화 시키는 중요 결정이었다.
### 왜 Go는 "implements"라는 선언이 없는가? ###
Go 타입은 단순히 해당 인터페이스의 메소드를 구현하기만 하면 인터페이스를 사용할 수 있다. 이런 특징은 기존 코드를 수정하지 않고도 인터페이스를 정의하고 사용할 수 있게 한다. 일종의 "duck typing"을 가능하게 한다. 이해관계를 분리시키고 코드의 재사용성을 높이고 코드가 늘어나면서 나타나는 패턴을 구성하기 쉽도록 한다. 인터페이스는 Go가 유연하고 가볍게 느껴지는 주용한 이유 중에 하나다.

줌더 자세한 내용은 왜 상속을 제공하지 않는지에 관한 내용을 보도록 하자.

### 내 타입(type)이 interface를 만족시키는지 어떻게 보장할 수 있을까? ###
컴파일러에게 type T가 해당 interface I를 구현하는지를 확인하는 방법은 아래와 같다.
```
type T struct{}
var _ I = T{}
```

만약 T가 I를 구현하지 않는다면 컴파일 시점에 바로 오류를 잡아낸다.

인터페이스를 사용하는 사람이 해당 인터페이스를 구현하고 있다는 것을 명시적으로 선언하기 원한다면 인터페이스의 메소드 집합에 이를 설명하는 이름의 메소드를 추가할 수 있다.
```
type Fooer interface {
	Foo()
	ImplementsFooer()
}
```

## 값(values) ##
### 왜 Go는 implicit numeric 변환을 제공하지 않는가? ###
C에서 numeric 타입들 사이에서 자동 변환은 편리하겠지만 혼돈으로 인해 무거워진다. unsigned expression일 때는 값이 얼마나 클까? 오버플로가 발생한게 아닐까? 실행되는 해당 시스템에 관계없이 결과가 동일한가? 이렇게 하는 경우 컴파일러는 복잡하게 된다. "일반 수식 변환(the usual arithmetic conversions)"은 구현하기 쉽지 않고 다른 구조를 가지는 시스템에서 일관성을 유지하기 어렵다. 이식성을 위해 코드에서 명시적인 변환의 비용이 발생하더라도 명확하고 직관적으로 진행하기로 했다. Go에서 상수의 정의는(부화와 크기) 상당히 개선하고 있다.

C와 다르게 관련된 내용은 int와 int64는 int가 비록 64bit 타입이더라도 구별되는 타입들이다. int 타입은 generic이다. 만약 정수(integer)가 얼마나 많은 bit를 가지는지 신경쓰지 않더라도 Go는 여러분이 명시적으로 정의하기를 바란다.
### 왜 map이 Go에 내장(built-in)되어 있는가? ###
string과 동일한 이유다. 강력하고 중요한 자료구조로서 프로그래밍을 즐겁게 만드는 문법과 멋진 구현을 제공한다. 우리는 Go에서 map의 구현이 대부분 경우에 사용할 수 있을만큼  강력하다고 믿고 있다. 만약 특정 어플리케이션에서 직접구현해서 이점이 있다면 직접 작성하는 것도 좋지만 문법적으로 편리하지는 않을 수 있다. 결국 트레이드 오프(trade off)가 있는거 같다.
### map에 키(key)로 struct와 array를 허용하는 것은 어떤가? ###
map 검색에는 equality 연산자가 필요한데 struct와 array에서 구현하지 않는다. 왜냐하면 equality가 해당 타입에 잘 정의되어 있지 않기 때문이다. 여기에는 shallow와 deep 비교, 포인터와 값 비교, 재귀구조 처리 등에 관련된 다양한 고려가 있다. 우리는 이런 이슈(struct와 array의 equality를 구현하는 것은 기존 프로그램에서 유효할 전망이다)들을 다시 다루겠지만 struct와 array의 equality가 의미에 대해 명확한 아이디어가 없다. 지금처럼 두는게 더 단순하다.
### array는 값인데 map, slice, channel은 참조(reference)인가? ###
이 주제에 대해서는 많은 뒷 이야기가 있다. 초창기에는 map과  channel은 문법적으로  포인터고 선언이 불가능하거나 포인터가 아닌 인스턴스(instance)를 사용했다. 또 array 어떻게 동작해야하는지에 고민이 많았다. 결국 포인터와 값의 엄격하게 분리시켜 언어를 사용하기 더욱 어렵게 만드는 결정을 내렸다. 참조타입(reference type)을 도입해서 array의 참조 형태를 처리하기 위해 slice를 포함하고 이 이슈를 해결했다. 참조타입은 언어에 복잡성을 추가하지만 사용성에 큰 영향을 준다. 이런게 도입되고 나서 Go는 더욱 생산성이 늘어나고 사용성이 편한 언어가 되었다.

## 코드 작성 ##
### 라이브러리 문서화는 어떻게 할까? ###
Go로 작성된 godoc라는 프로그램이 있다. 소스코드에서 package documentation을 추출한다.  커맨드 라인이나 웹에서 사용할 수 있다. 예로 http://golang.org/pkg/에서 운영중이다. 사실 godoc는 http://golang.org 전체 사이트를 실행시킨다.
### Go 프로그래밍 스타일 가이드가 있나? ###
네이밍(naming), 레이아웃, 파일구성과 같은 것에 대한 가이드하는 몇가지 원칙이 있다. EffectiveGo문서에서 일부 스타일을 제시하고 있다. 더 직접적으로 gofmt는 레이아웃 원칙을 따르게 하기 위한 도구이다. 해석해서 허용되지 않는 것을 허용되는 형태로 바꿔준다. 저장소에 있는 모든 Go코드는 gofmt를 실행시킨다.

### Go 라이브러리에 패치(patch)를 보내는 방법은? ###
라이브러리 소스는 go/src/pkg에 있다. 만약 중요한 변경을 원하면 메일링 리스트에서 논의를 먼저 거치기 바란다. [Go 프로젝트](http://golang.org/doc/contribute.html)에 기여하는 방법을 참고한다.

## 포인터와 할당(Pointer와 Allocation) ##
### 함수 인자가 값으로 전달(passed by value)되는 경우는? ###
Go에서 모든것은 값에 의한 전달(passed by value)이다. 함수는 항상 전달할 것의 복사본을 얻는데 이는 마치 인자에 값을 할당하는 할당구문과 같다. 예를 들면, 값은 포인터의 복사본을 만들며 포인터가 가리키는 data가 아니다.

map과 slice 값은 포인터처럼 동작한다. 원래의 map과 slice data에 대한 포인터들을 포함하는 설명자가 있다. map과 slice값의 복사는 이것이 가리키는 data를 copy하지는 않는다. 인터페이스 값의 복사는 인터페이스 값에 저장된 것의 복사본을 만든다. 만약 인터페이스 값이 struct를 가지고 있다면, 인터페이스 값을 복사하는 것은 struct의 복사본을 만드는 것과 같다. 만약 인터페이스 값이 포인터를 가지고 있다면 인터페이스 값을 복사하는 것은 포인터를 복사이지 이것이 가리키는 data를 다시 복사하는 것은 아니다.

### 메소드를 정의하는 것은 값으로 해야하나 포인터로 해야하나? ###
```
func (s *MyStruct) someMethod() { } // method on pointer
func (s MyStruct) someMethod() { }  // method on value
```

어떤 타입의 메소드를 정의할 때, 수신자(receiver. 위 예제에서는 s)는 이것이 메소드의 인자인것처럼 정확히 동작한다. 만약 수신자가 가리키는 data를 수정하기 위한 메소드가 필요한 경우 포인터 타입으로 메소드를 정의하라. 반면에 일반적인 경우에는 그냥 값타입으로 정의하는게 더 명확할 수 있다.

### new와 make 사이에 차이점이 뭐지? ###
짧게 말해서 new는 메모리를 할당하고 make는 slice, map, channel 타입을 초기화하는데 사용된다. 관련해서 EffectiveGo를 참조하라.

### 왜 64bit 장치에서 int는 32 bit인가? ###
int와 uint의 크기는 구현스펙이지만 해당 플랫폼에서 서로 같다. 64bit Go 컴파일러(6g와 gccgo)는 int를 표현하는데 32bit를 사용한다. 값의 특정 크기에 의존하는 코드는 int64와 같이 명시인 크기의 타입을 사용해야만 한다. 반면에 부동소수점을 가지는 수와 복소수는 항상 크기를 명시해야 한다. 예를들면 float32, complex64 와 같이 명시한다. 왜냐하면 프로그래머는 부동소수점 수를 사용하는 경우에 정확도(precision)을 알고 있어야 하기 때문이다.

### 힙(heap)이나 스택(stack)에 값이 할당되었는지 아닌지 어떻게 알 수 있지? ###
정확성의 관점으로 본다면 알 필요는 없다. Go에서 각 변수는 참조가 존재하는 한 계속 남아 있다. 해당 구현에서 선택한 저장 위치는 언어의 의미와 관계가 없다.
저장 위치는 효율적인 프로그램을 작성하는데 효과가 있다. 가능하면 Go 컴파일러는 변수를 함수의 스택 프레임(stack frame)에 있는 함수에 지역변수로 할당한다. 그러나 컴파일러가 함수가 리턴되고 난 후에 변수가 참조되지 않는다는 것을 증명할 수 없다면 컴파일러는 dangling pointer 오류를 피하기 위해서 가비지 콜렉션이 되는 힙에 변수를 할당해야만 한다.

현재 컴파일러들에서 분석은 초보 단계다. 만약 어떤 변수가 주소를 가지면 변수는 힙(heap)에 할당된다. 이러한 분석을 개선하기 위한 작업을 하다보니 더 많은 데이터가 스택(stack)에 유지된다.
## 동시성(Concurrency) ##
### 어떤 연산이 atomic인가? 뮤텍스(mutex)는? ###
아직 완전히 정의하지는 못했지만 원자성(atomicity)에 대한 일부 세부적인 사항은 [Go Memory Model specification](.md)에 있다.

뮤텍스(mutexes)는 sync 패키지에서 구현하고 있지만 Go 프로그래밍 스타일로 사람들이 좀더 상위 레벨 기술을 시도할 수 있게 할 예정이다. 특정 시점에 하나의 goroutine만이 특정 data에 대해 책임을 지도록 프로그램 구성을 고려해야 한다.

메모리 공유로 통신하는 것이 아니라 통신을 통해 메모리를 공유한다.

[통신에 의한 메모리 공유](http://golang.org/doc/codewalk/sharemem/)를 보고 이 개념과 관련된 상세한 논의를 관련된 문서를 보도록 하자.

### 다중 goroutine 프로그램이 다중 CPU가 아닌 환경에서 돌아가면? ###
gc 컴파일러에서는 하나 이상의 OS 쓰레드를 사용하기 위해 런타임을 지원하도록
> GOMAXPROCS를 설정해야만 한다. gccgo 컴파일러에서는 각 goroutine 마다 OS 쓰레드가 생성되며 실제로 GOMAXPROCS는 실행되는 goroutine의 수와 같다.

### GOMAXPROCS > 1를 사용하면 왜 가끔 프로그램이 느려지나? ###
이것은 gc 컴파일러의 특징이다. 위 참조.
여러분이 작성하는 프로그램에 달려있다. channel로 통신하는 시간이 많이 걸리는 여러 goroutine을 포함하는 프로그램은 다중 OS 쓰레드를 사용할 때 성능 저하를 경험할 수도 있다. 쓰레드들 사이에서 data를 보내는데 관련된 컨텍스트 스위칭(context-switching) 때문이다.

Go의 goroutine 스케쥴러는 현재 원하는 수준까지는 아니다. 앞으로 해당 경우를 OS 쓰레드 사용을 최적화할 예정이다. 현재는 GOMAXPROCS는 application마다 설정되도록 해야한다.

## 함수(Function)와 메소드(Method) ##
### 왜 T와 `*T`는 다른 메소드 집합을 가지나? ###
Go Spec을 보면:
> 다른 이름을 가지는 Type T의 메소드 집합은 수신자(receiver) Type T인 모든 메소드들로 구성되어 있다. 포인터 `Type *T`에 대응되는 메소드 집합은 수자로 `*T`나 T를 가지는 모든 메소드의 집합이다.(즉 T의 메소드 집합 포함한다.)

만약 인터페이스 값이 포인터 `*T`를 포함한다면 메소드 호출은 인터를 역참조함으써 값을 얻을 수 있다. 하지만 인터페이스 값이 값 T를 포함한다면 메소드 호출이 포인터를 얻는 것은 좋은 방법은 아니다.

이런 제한이 없다면, 코드는 아래와 같다.
var buf bytes.Buffer
io.Copy(buf, os.Stdin)
standard input을 buf 자체로 복사하는 것이 아니라 buf의 복사본으로 복사하게 된다. 이건 원하는 동작이 아니다.

### 클로져(closure)가 goroutine처럼 동작하는 방식 때문에 헷갈려요. ###
클로저(closure)를 동시성(concurrency)과 같이 사용하는 경우 일부 혼란이 있을 수 있다. 다음과 같은 경우를 보자.
```
func main() {
	done := make(chan bool)

	values := []string{ "a", "b", "c" }
	for _, v := range values {
		go func() {
			fmt.Println(v)
			done <- true
		}()
	}

	// wait for all goroutines to complete before exiting
	for _ = range values {
		<-done 
	}
}
```
## 제어(Control flow) ##
### Go에서 '?:' 이런 연산자가 있나요? ###
Go에는 3개를 하나로 표현(ternary form)하는 것이 없다. 아래와 같이 작성해야 한다.
```
if expr {
	n = trueVal
} else {
	n = falseVal
}
```

## 패키지(Package)와 테스팅(Testing) ##
### 여러 파일을 가지는 패키지는 어떻게 만드나요? ###
해당 패키지에 대한 소스 파일들을 하나의 디렉토리에 넣어야한다. 소스 파일은 다른 파일에서 아이템에 대해서 참조가 가능하다. 먼저 선언이나 헤더파일이 필요하지 않다.

여러 파일들로 나눠진다기 보다는 해당 패키지는 마치 하나의 패키지 파일처럼 컴파일하고 테스트된다.
### 단위테스트(unit test)를 어떻게 작성하나요? ###
패키지 소스와 동일한 디렉토리에 파일 이름이 "_test.go"로 끝나는 파일을 생성한다. 그 파일에서 "testing"을 import하고 아래와 같은 형태로 함수를 작성한다.
```
func TestFoo(t *testing.T){
	...
}
```_

gotest를 해당 디렉토리에서 실행하자. 스크립트는 Test 함수를 찾고 테스트 바이너리를 빌드하고 실행한다. 좀더 자세한 내용은 HowToWriteGoCode 문서를 참고하자.

## 구현(Implementation) ##
### 컴파일러를 빌드하는데 사용한 컴파일러 기술은 뭔가요? ###
Gccgo는 front-end로 C++(recursive descent parser)을 back-end로 표준 GCC를 가진다. Gc는 파서를 위해서 yacc/bison을 사용해서 C로 구현되어있다. 비록 새로운 프로그램이지만 Plan 9C 컴파일러(http://plan9.bell-labs.com/sys/doc/compiler.html)에 잘 맞고 ELF 바이너리를 생성하는 Plan 9 로더(loader)의 변형를 사용할 수 있다.

원래 Go compiler인 6g를 고려했지만 부트스트래핑의 어려움과 오픈 소스 배포 때문에 선택하지 않았다. Go 환경을 설정하는데 Go 컴파일러가 필요하다. 뒤에 나온 Gccgo는 Go에서 컴파일러를 작성하는 것을 가능하게 작성이 용이할 것이다. Go는 컴파일러를 구현하기에 괜찮은 언어이다. 왜냐하면 lexer와 parser가 이미 /pkg/go에 있기 때문이다.

6g에 대해서 LLVM을 사용을 고려하고 있지만 우리의 성능 목표를 달성하기에 너무 크고, 느릴꺼 같다.

### 어떤 방식으로 런타임 지원이 구현되었나요? ###
부트스트래핑(bootstrapping) 이슈 때문에 런타임 코드는 거의 C(assembler로 된 부분이 약간)로 되어있다. 하지만 Go는 현재 이의 대부분을 구현할수 있는 상태다. Gccgo의 런타임 지원은 glibc를 사용한다. Gc는 footprint를 제어를 지속하기 위해 커스텀 라이브러리를 사용하며 goroutines에서 세그멘티드 스택(segmented stack)을 지원하는 Plan 9C 컴파일러 버전으로 컴파일 한다. gccgo에서 동일한 스택 관리를 제공하기 위해서 현재 작업 중이다.

### 왜 간단한 프로그램이 큰 사이즈의 바이너리가 되나요? ###
gc 툴체인(5l, 6l, 8l)은 정적 링크 바이너리만을 생성한다. 따라서 모든 Go 바이너리는 동적 타입 체크(dynamic type check)를 지원하는데 필요한 런타임 타입 정보를 가지는 Go 런타임, 리플렉션(reflection), panic-time 스택 추적을 포함한다.

간단한 C로 작성된 "hello, world"을 gcc를 사용해서 컴파일 및 정적 링크하면 대략 750kB다. 동일한 Go 프로그램은 대략 1.1MB지만 더욱 강력한 런타임 지원을 포함하고 있다. Go 바이너리는 노력해서 줄일 수 있다고 믿고 있다.
## 성능 ##
### 왜 Go는 벤치마크에서 안좋은 성능을 보여줬나요? ###
Go설계 목표 중에 하나는 비교가능한 프로그램에서 C의 성능에 근접하는 것이다. 아직 일부 벤치마크 및 test/bench에서 일부에서 성능상 뒤지고 있다. 아주 느리게 나온 것들은
Go에서 지원하고 있지 않는 라이브러리를 이용하여 비교가 이루어져서다. 예를 들면 pidigits는 multi-precision math 패키지에 의존하고 C버전은 Go와 달리 GMP(어셈블러로 최적화되어 작성됨)를 사용한다. 정규표현식(예를 들면 regex-dna)에 의존하는 벤치마크는 본질적으로 Go의 stopgap regexp 패키지를 이미 최적화된 것(PCRE와 같은 고도로 최적화된 라이브러리)과 비교한다.

벤치마크 게임은 확장 튜닝을 통해 이길수 있고 벤치마크하는 대부분의 Go버전에도 처리가 필요하다. 여러분이 C와 Go 프로그램을 비교한다면 발표된 것보다 실제 성능이 비슷하다는 것을 알 수 있을 것이다.

여전히 개선의 여지는 있다. 컴파일러들도 현재보다 더 개선이 가능하며 많은 라이브러리에서 성능개선 작업이 필요하다. 그리고 가비지 콜렉션은 아직 만족할 만큼 빠른 성능을 보이지 않고 있다. (성능이 좋지 않더라도, 불필요한 가비지(garbage)를 생성하지 않으면 엄청난 효과를 얻을 수 있다.)
## C와 다른점 ##
### 왜 문법이 C와 차이가 많은가요? ###
선언 문법을 제외하고 차이가 크지 않다. 먼저 문법은 가볍게 느껴져야 하며 키워드(keyword)가 적고, 반복, 감춰진 내용이 없어야 한다. 두번째로 언어는 분석하기 쉽고 심볼 테이블이 없더라도 파싱이 가능해야 한다. 이렇게 하면 디버거, 의존성 분석, 자동화 문서 추출기, 통합개발환경 플러그인 등과 같은 도구를 만들기가 훨씬 쉬워진다. C와 그 계열의 언어들은 이런 것들이 어렵기로 악명이 높다.

### 선언부가 왜 뒤에 오나요? ###
여러분이 C에 익숙하겠지만 이는 그냥 뒤에 두는 것이다. C에서 변수는 타입을 지정하는 표현식과 같이 지정한다. 이것은 좋은 아이디어지만 타입과 표현식 문법은 잘 혼합되지 않고 결과적으로 헷갈리게 된다. 함수 포인터를 예를 들어보자. Go는 표현식과 타입 문법을 분리하고 단순화 시켰다.(포인터를 위해 앞쪽에 `*`를 붙이기 되므로 법칙을 이해하는데 예외가 생긴다.)
C에서 선언은
```
int* a, b;
```
a는 포인터로 선언되지만 b는 그렇게 되지 않는다. Go에서는 아래와 같다.
```
var a, b *int;
```
모두 포인터로 선언된다. 이렇게 하면 더 명확하고 규칙성을 가진다. ':='와 같은 짧은 선언 형태는 완전한 변수 선언과 같은 순서로 표현되어야 한다.
```
var a uint64 = 1;
```
아래와 동일한 효과다.
```
a := uint64(1);
```
파싱을 단순화시키기 위해서 타입에 대해서 독특한 문법을 가진다. func과 chan과 같은 키워드를 이용해서 명확하게 한다.
### 왜 포인터 연산이 없나요? ###
안전성을 위해서다. 포인터 연산이 없으면 절대로 잘못된 주소를 얻어오지 못하는 언어를 만드는게 가능하다. 컴파일러와 하드웨어 기술은 array의 인덱스를 이용하는 루프(loop)가 포인터 연산을 이용하는 루프(loop)만큼 효율적인 시점만큼 앞서나가고 있다. 또한 포인터 연산의 부족은 가비지 콜렉터의 구현을 단순화 할 수 있다.

### 왜 ++과 --가 expression이 아니라 statement인가요? prefix가 아니라 postfix인건가요? ###
포인터 연산 없으면 증가/감소 시키는 연산자의 가치가 떨어진다. expression문법을 단순화하고 ++과 --를 앞뒤에 따라 값을 구하는 방식(`f(i++)과 p[i]=q[++i]`) 등의 이슈도 없어지게 된다. 단순화시키는 것이 중요하다.

### 중괄호'{}'는 있는데 세미콜론이 없나요? 그리고 다음 행 시작부분에 '{'를 사용 못하는 이유는요? ###
Go는 구문블록(statement block)에 대해서 중괄호를 이용한다. C계열의 언어로 작업하는 프로그래머에게 친근한 문법이다. 그러나 세미콜론은 사람이 아니라 파싱을 위한 것이다. 따라서 우리는 최대한 세미콜론을 줄이고 싶었다. 이 목표를 달성하기 위해서 BCPL(정식문법에서 구문을 분리하는데 세미콜론을 사용하는데 자동으로 세미콜론을 넣어주도록 했다)의 방법을 사용한다. 결국 구문의 끝에 어휘분석기(lexer)가 세미콜론을 넣어준다. 이렇게 하면 괄호사용방식을 강요하게 되지만 실전에서는 아주 실용적이다. 예를 들면 코드라인에서 함수의 시작 괄호만 사용하는 것을 볼 수 없다.

일부에서는 다음 행에 괄호를 허용하도록 어휘분석기가 미리 검사하는 것을 주장하고 있다. 우리는 동의하지 않는다. Go코드는 gofmt로 자동으로 형식을 맞춰주기 때문에 스타일은 반드시 선택해야만 한다. 이런 스타일이 C나 Java에서 사용하는 것과 다를 수 있지만 Go는 새로운 언어이고 gofmt의 스타일도 다른 언어만큼 좋다. Go프로그램에서 단일하게 정해진 포맷에서 얻는 장점이 특정 스타일에서 오는 단점이 있더라도 훨씬 능가한다. 또한 Go의 스타일이란 Go의 상호구현에 있어 특별한 규칙없이도 동시에 표준 문법을 사용할 수 있다는 것을 말한다.

### 왜 가비지 콜렉션(garbage collection)을 하나요? 리소스가 많이 드는거 아닌가요? ###
시스템 프로그램에서 가장 많은 소스 부분을 차지하는 것 중에 하나가 메모리 관리(memory management)이다. 프로그래머의 오버헤드를 줄여이는데 결정정이라고 생각하며 지난 몇 해 동안에 가비지 콜렌션 기술에 발전은 충분히 낮은 오버헤드와 적은 지연시간으로 구현이 가능하다는 자신감을 줬다.(현재 구현은 평이한 mark-and-sweep collector 방식이지만 현재 교체작업 중에 있다.)

또 다른 점은 동시성의 어려움으로 인한 부분이며 멀티 쓰레드 프로그래밍은 메모리 관리다. 객체들이 쓰레들 사이에서 전달되므로 안전성을 보장하는 것이 성가신 일이 되었다. 자동 가비지 콜렉션은 동시성을 지원하는 코들르 아주 쉽게 작성할 수 있게 돕는다. 물론 동시성을 가지는 환경에서 가비지 콜렉션을 구현하는 것은 자체가 도전이지만 매 프로그램마다 처리하는 것보다는 한 번에 맞춰놓는게 좋겠다.